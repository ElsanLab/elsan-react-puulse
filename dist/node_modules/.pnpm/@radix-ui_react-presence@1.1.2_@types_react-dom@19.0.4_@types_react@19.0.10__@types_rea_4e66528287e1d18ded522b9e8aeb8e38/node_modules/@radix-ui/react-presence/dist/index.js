var T = Object.defineProperty;
var u = (n, e) => T(n, "name", { value: e, configurable: !0 });
import * as a from "react";
import { useComposedRefs as R } from "../../../../../@radix-ui_react-compose-refs@1.1.1_@types_react@19.0.10_react@19.0.0/node_modules/@radix-ui/react-compose-refs/dist/index.js";
import { useLayoutEffect as M } from "../../../../../@radix-ui_react-use-layout-effect@1.1.0_@types_react@19.0.10_react@19.0.0/node_modules/@radix-ui/react-use-layout-effect/dist/index.js";
function v(n, e) {
  return a.useReducer((r, t) => e[r][t] ?? r, n);
}
u(v, "useStateMachine");
var P = /* @__PURE__ */ u((n) => {
  const { present: e, children: r } = n, t = w(e), i = typeof r == "function" ? r({ present: t.isPresent }) : a.Children.only(r), m = R(t.ref, y(i));
  return typeof r == "function" || t.isPresent ? a.cloneElement(i, { ref: m }) : null;
}, "Presence");
P.displayName = "Presence";
function w(n) {
  const [e, r] = a.useState(), t = a.useRef({}), i = a.useRef(n), m = a.useRef("none"), A = n ? "mounted" : "unmounted", [p, s] = v(A, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return a.useEffect(() => {
    const o = N(t.current);
    m.current = p === "mounted" ? o : "none";
  }, [p]), M(() => {
    const o = t.current, d = i.current;
    if (d !== n) {
      const l = m.current, c = N(o);
      n ? s("MOUNT") : c === "none" || (o == null ? void 0 : o.display) === "none" ? s("UNMOUNT") : s(d && l !== c ? "ANIMATION_OUT" : "UNMOUNT"), i.current = n;
    }
  }, [n, s]), M(() => {
    if (e) {
      let o;
      const d = e.ownerDocument.defaultView ?? window, f = /* @__PURE__ */ u((c) => {
        const O = N(t.current).includes(c.animationName);
        if (c.target === e && O && (s("ANIMATION_END"), !i.current)) {
          const E = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", o = d.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = E);
          });
        }
      }, "handleAnimationEnd"), l = /* @__PURE__ */ u((c) => {
        c.target === e && (m.current = N(t.current));
      }, "handleAnimationStart");
      return e.addEventListener("animationstart", l), e.addEventListener("animationcancel", f), e.addEventListener("animationend", f), () => {
        d.clearTimeout(o), e.removeEventListener("animationstart", l), e.removeEventListener("animationcancel", f), e.removeEventListener("animationend", f);
      };
    } else
      s("ANIMATION_END");
  }, [e, s]), {
    isPresent: ["mounted", "unmountSuspended"].includes(p),
    ref: a.useCallback((o) => {
      o && (t.current = getComputedStyle(o)), r(o);
    }, [])
  };
}
u(w, "usePresence");
function N(n) {
  return (n == null ? void 0 : n.animationName) || "none";
}
u(N, "getAnimationName");
function y(n) {
  var t, i;
  let e = (t = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : t.get, r = e && "isReactWarning" in e && e.isReactWarning;
  return r ? n.ref : (e = (i = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : i.get, r = e && "isReactWarning" in e && e.isReactWarning, r ? n.props.ref : n.props.ref || n.ref);
}
u(y, "getElementRef");
export {
  P as Presence
};
