var y = Object.defineProperty;
var n = (e, r) => y(e, "name", { value: r, configurable: !0 });
var H = /* @__PURE__ */ n(function(e) {
  return e.tagName === "TEXTAREA";
}, "alwaysContainsScroll"), g = /* @__PURE__ */ n(function(e, r) {
  if (!(e instanceof Element))
    return !1;
  var o = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    o[r] !== "hidden" && // contains scroll inside self
    !(o.overflowY === o.overflowX && !H(e) && o[r] === "visible")
  );
}, "elementCanBeScrolled"), B = /* @__PURE__ */ n(function(e) {
  return g(e, "overflowY");
}, "elementCouldBeVScrolled"), V = /* @__PURE__ */ n(function(e) {
  return g(e, "overflowX");
}, "elementCouldBeHScrolled"), L = /* @__PURE__ */ n(function(e, r) {
  var o = r.ownerDocument, t = r;
  do {
    typeof ShadowRoot < "u" && t instanceof ShadowRoot && (t = t.host);
    var f = b(e, t);
    if (f) {
      var a = m(e, t), i = a[1], l = a[2];
      if (i > l)
        return !0;
    }
    t = t.parentNode;
  } while (t && t !== o.body);
  return !1;
}, "locationCouldBeScrolled"), D = /* @__PURE__ */ n(function(e) {
  var r = e.scrollTop, o = e.scrollHeight, t = e.clientHeight;
  return [
    r,
    o,
    t
  ];
}, "getVScrollVariables"), R = /* @__PURE__ */ n(function(e) {
  var r = e.scrollLeft, o = e.scrollWidth, t = e.clientWidth;
  return [
    r,
    o,
    t
  ];
}, "getHScrollVariables"), b = /* @__PURE__ */ n(function(e, r) {
  return e === "v" ? B(r) : V(r);
}, "elementCouldBeScrolled"), m = /* @__PURE__ */ n(function(e, r) {
  return e === "v" ? D(r) : R(r);
}, "getScrollVariables"), W = /* @__PURE__ */ n(function(e, r) {
  return e === "h" && r === "rtl" ? -1 : 1;
}, "getDirectionFactor"), N = /* @__PURE__ */ n(function(e, r, o, t, f) {
  var a = W(e, window.getComputedStyle(r).direction), i = a * t, l = o.target, s = r.contains(l), c = !1, d = i > 0, h = 0, S = 0;
  do {
    var u = m(e, l), v = u[0], C = u[1], p = u[2], w = C - p - a * v;
    (v || w) && b(e, l) && (h += w, S += v), l instanceof ShadowRoot ? l = l.host : l = l.parentNode;
  } while (
    // portaled content
    !s && l !== document.body || // self content
    s && (r.contains(l) || r === l)
  );
  return (d && Math.abs(h) < 1 || !d && Math.abs(S) < 1) && (c = !0), c;
}, "handleScroll");
export {
  N as handleScroll,
  L as locationCouldBeScrolled
};
