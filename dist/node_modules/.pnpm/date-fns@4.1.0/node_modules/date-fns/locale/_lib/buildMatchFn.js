var o = Object.defineProperty;
var r = (t, n) => o(t, "name", { value: n, configurable: !0 });
function m(t) {
  return (n, e = {}) => {
    const l = e.width, f = l && t.matchPatterns[l] || t.matchPatterns[t.defaultMatchWidth], d = n.match(f);
    if (!d)
      return null;
    const c = d[0], u = l && t.parsePatterns[l] || t.parsePatterns[t.defaultParseWidth], h = Array.isArray(u) ? k(u, (i) => i.test(c)) : (
      // [TODO] -- I challenge you to fix the type
      P(u, (i) => i.test(c))
    );
    let a;
    a = t.valueCallback ? t.valueCallback(h) : h, a = e.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      e.valueCallback(a)
    ) : a;
    const s = n.slice(c.length);
    return { value: a, rest: s };
  };
}
r(m, "buildMatchFn");
function P(t, n) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e) && n(t[e]))
      return e;
}
r(P, "findKey");
function k(t, n) {
  for (let e = 0; e < t.length; e++)
    if (n(t[e]))
      return e;
}
r(k, "findIndex");
export {
  m as buildMatchFn
};
