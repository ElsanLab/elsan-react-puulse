var M = Object.defineProperty;
var r = (e, t) => M(e, "name", { value: t, configurable: !0 });
import * as l from "react";
import { useComposedRefs as _ } from "../../../../../@radix-ui_react-compose-refs@1.1.1_@types_react@19.0.10_react@19.0.0/node_modules/@radix-ui/react-compose-refs/dist/index.js";
import { Primitive as K } from "../../../../../@radix-ui_react-primitive@2.0.2_@types_react-dom@19.0.4_@types_react@19.0.10__@types_re_eba4716596d4f139c393e6187e0b8922/node_modules/@radix-ui/react-primitive/dist/index.js";
import { useCallbackRef as N } from "../../../../../@radix-ui_react-use-callback-ref@1.1.0_@types_react@19.0.10_react@19.0.0/node_modules/@radix-ui/react-use-callback-ref/dist/index.js";
import { jsx as k } from "react/jsx-runtime";
var T = "focusScope.autoFocusOnMount", h = "focusScope.autoFocusOnUnmount", O = { bubbles: !1, cancelable: !0 }, w = "FocusScope", x = l.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: u = !1,
    onMountAutoFocus: E,
    onUnmountAutoFocus: g,
    ...U
  } = e, [o, A] = l.useState(null), v = N(E), b = N(g), F = l.useRef(null), P = _(t, (s) => A(s)), f = l.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  l.useEffect(() => {
    if (u) {
      let s = /* @__PURE__ */ r(function(a) {
        if (f.paused || !o) return;
        const i = a.target;
        o.contains(i) ? F.current = i : d(F.current, { select: !0 });
      }, "handleFocusIn2"), m = /* @__PURE__ */ r(function(a) {
        if (f.paused || !o) return;
        const i = a.relatedTarget;
        i !== null && (o.contains(i) || d(F.current, { select: !0 }));
      }, "handleFocusOut2"), c = /* @__PURE__ */ r(function(a) {
        if (document.activeElement === document.body)
          for (const y of a)
            y.removedNodes.length > 0 && d(o);
      }, "handleMutations2");
      document.addEventListener("focusin", s), document.addEventListener("focusout", m);
      const p = new MutationObserver(c);
      return o && p.observe(o, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", s), document.removeEventListener("focusout", m), p.disconnect();
      };
    }
  }, [u, o, f.paused]), l.useEffect(() => {
    if (o) {
      C.add(f);
      const s = document.activeElement;
      if (!o.contains(s)) {
        const c = new CustomEvent(T, O);
        o.addEventListener(T, v), o.dispatchEvent(c), c.defaultPrevented || (D(q(L(o)), { select: !0 }), document.activeElement === s && d(o));
      }
      return () => {
        o.removeEventListener(T, v), setTimeout(() => {
          const c = new CustomEvent(h, O);
          o.addEventListener(h, b), o.dispatchEvent(c), c.defaultPrevented || d(s ?? document.body, { select: !0 }), o.removeEventListener(h, b), C.remove(f);
        }, 0);
      };
    }
  }, [o, v, b, f]);
  const R = l.useCallback(
    (s) => {
      if (!n && !u || f.paused) return;
      const m = s.key === "Tab" && !s.altKey && !s.ctrlKey && !s.metaKey, c = document.activeElement;
      if (m && c) {
        const p = s.currentTarget, [a, i] = H(p);
        a && i ? !s.shiftKey && c === i ? (s.preventDefault(), n && d(a, { select: !0 })) : s.shiftKey && c === a && (s.preventDefault(), n && d(i, { select: !0 })) : c === p && s.preventDefault();
      }
    },
    [n, u, f.paused]
  );
  return /* @__PURE__ */ k(K.div, { tabIndex: -1, ...U, ref: P, onKeyDown: R });
});
x.displayName = w;
function D(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const u of e)
    if (d(u, { select: t }), document.activeElement !== n) return;
}
r(D, "focusFirst");
function H(e) {
  const t = L(e), n = S(t, e), u = S(t.reverse(), e);
  return [n, u];
}
r(H, "getTabbableEdges");
function L(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: /* @__PURE__ */ r((u) => {
      const E = u.tagName === "INPUT" && u.type === "hidden";
      return u.disabled || u.hidden || E ? NodeFilter.FILTER_SKIP : u.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }, "acceptNode")
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
r(L, "getTabbableCandidates");
function S(e, t) {
  for (const n of e)
    if (!V(n, { upTo: t })) return n;
}
r(S, "findVisible");
function V(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
r(V, "isHidden");
function W(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
r(W, "isSelectableInput");
function d(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && W(e) && t && e.select();
  }
}
r(d, "focus");
var C = j();
function j() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = I(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = I(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
r(j, "createFocusScopesStack");
function I(e, t) {
  const n = [...e], u = n.indexOf(t);
  return u !== -1 && n.splice(u, 1), n;
}
r(I, "arrayRemove");
function q(e) {
  return e.filter((t) => t.tagName !== "A");
}
r(q, "removeLinks");
export {
  x as FocusScope
};
